Parser

We implemented a recursive-decent parser using an infinite pushdown automaton, simply speaking the most important tool we need are recursive method calls. Consider the following part of our EBNF:

class = {scope} "class" identifier "{" classBody "}"
classBody = {method}
method = {scope} returnType identifier "{" StatementSequence "}"

The main method of our parser just calls the parseClass()-method. This method e.g. utilizes the parseClassBody()-method to parse a list of class methods. parseClassBody() itself calls parseMethod() to parse each method, parseMethod uses parseStatementSequence and so on. This continues until a terminal symbol is reached.

Consider another part of the EBNF:
factor = identifier | number | "(" expression ")"
expression = simpleExpression [ ("=", "<", ">", "<=", ">=", "!=") SimpleExpression ]
simpleExpression = ["+"|"-"] term {("+"|"-") term}.
term = factor {("*" | "/" | "%") factor}

Here we see, that recursion is needed, because one or more factors are part of an expression and a factor itsef can also include an expression.

In the process of parsing, results are saved in an object-tree, whose top-element represents a class in our language. As code is generated during parsing, the saving of a complete tree might not be necessary, but this clear object-orientated approach prooved to be helpful while programming our parser.

As for the scanner, we wrote several unit tests to check our parser against different types of input data. This work quickly paid off as tracing down and fixing bugs would have been a lot harder without having unit tests. E.g. a small addition to the parser might break some other part of it. If we have a test for that part, this can be immediately noticed and fixed. If we would not have the tests, the error might only appear at a later time, at which it is difficult to say, which code change produced it. To sum it up, unit tests were our most important tool during programming the compiler.
Besides testing predefined input data and the parser's output for it, we also parse random input data as well as a random set of tokens to "make sure" the parser does not crash on any given input. Of course unit tests are no guarantee for our parser to work correctly, but they help minimizing the risk of undetected errors.

The complete EBNF for the parser looks as follows:
scope = "public" | "private" | "protected"
class = {scope} "class" identifier "{" {method} "}"
mainMethod = "public" "static" "void" "main" "String" "args" "[" "]" "{" statementSequence "}"
method = {scope} returnType identifier "{" StatementSequence "}"
returnType = basicType
statementSequence = [statement] { ";" statement }
statement = assignment | declaration | ifStatement | whileStatement | doStatement
ifStatement = "if" "(" expression ")" "{" statementSequence "}" {elseifBlock} [elseBlock]
elseifBlock = "else" "if" "(" expression ")" "{" statementSequence "}"
elseBlock = "else" "(" expression ")" "{" statementSequence "}"
whileStatement = "while" "(" expression ")" "{" statementSequence "}"
doStatement = "do" "(" statementSequence ")" "while" "(" expression ")" 
assignment = identifier selector "=" expression
selector = {"." identifier | "[" expression "]"}
factor = identifier selector | number | "(" expression ")"
expression = simpleExpression [("=", "<", ">", "<=", ">=", "!=") SimpleExpression]
simpleExpression = ["+"|"-"] term {("+"|"-") term}.
term = factor {("*" | "/" | "%") factor}